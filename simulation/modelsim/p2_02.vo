// Copyright (C) 2023  Intel Corporation. All rights reserved.
// Your use of Intel Corporation's design tools, logic functions 
// and other software and tools, and any partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Intel Program License 
// Subscription Agreement, the Intel Quartus Prime License Agreement,
// the Intel FPGA IP License Agreement, or other applicable license
// agreement, including, without limitation, that your use is for
// the sole purpose of programming logic devices manufactured by
// Intel and sold by Intel or its authorized distributors.  Please
// refer to the applicable agreement for further details, at
// https://fpgasoftware.intel.com/eula.

// VENDOR "Altera"
// PROGRAM "Quartus Prime"
// VERSION "Version 22.1std.2 Build 922 07/20/2023 SC Lite Edition"

// DATE "10/21/2023 15:09:31"

// 
// Device: Altera EPM240T100C5 Package TQFP100
// 

// 
// This Verilog file should be used for ModelSim (Verilog) only
// 

`timescale 1 ps/ 1 ps

module main_module (
	status,
	columns_attack,
	rows_attack,
	attack_button,
	game_charge_button,
	save_game_button,
	reset_save_game_button,
	clock,
	columns,
	lines,
	clock_output);
input 	[1:0] status;
input 	[2:0] columns_attack;
input 	[2:0] rows_attack;
input 	attack_button;
input 	game_charge_button;
input 	save_game_button;
input 	reset_save_game_button;
input 	clock;
output 	[4:0] columns;
output 	[6:0] lines;
output 	clock_output;

// Design Ports Information


wire gnd;
wire vcc;
wire unknown;

assign gnd = 1'b0;
assign vcc = 1'b1;
assign unknown = 1'bx;

tri1 devclrn;
tri1 devpor;
tri1 devoe;
wire \clock~combout ;
wire \clock_divider|count[0]~1 ;
wire \clock_divider|count[0]~1COUT1_33 ;
wire \clock_divider|count[1]~3 ;
wire \clock_divider|count[1]~3COUT1_34 ;
wire \clock_divider|count[2]~5 ;
wire \clock_divider|count[3]~7 ;
wire \clock_divider|count[3]~7COUT1_35 ;
wire \clock_divider|count[4]~9 ;
wire \clock_divider|count[4]~9COUT1_36 ;
wire \clock_divider|count[5]~11 ;
wire \clock_divider|count[5]~11COUT1_37 ;
wire \clock_divider|count[6]~13 ;
wire \clock_divider|count[6]~13COUT1_38 ;
wire \clock_divider|count[7]~15 ;
wire \clock_divider|count[8]~17 ;
wire \clock_divider|count[8]~17COUT1_39 ;
wire \clock_divider|count[9]~19 ;
wire \clock_divider|count[9]~19COUT1_40 ;
wire \clock_divider|count[10]~21 ;
wire \clock_divider|count[10]~21COUT1_41 ;
wire \clock_divider|Equal0~3_combout ;
wire \clock_divider|count[11]~23 ;
wire \clock_divider|count[11]~23COUT1_42 ;
wire \clock_divider|count[12]~25 ;
wire \clock_divider|count[13]~27 ;
wire \clock_divider|count[13]~27COUT1_43 ;
wire \clock_divider|count[14]~29 ;
wire \clock_divider|count[14]~29COUT1_44 ;
wire \clock_divider|Equal0~4_combout ;
wire \clock_divider|Equal0~0_combout ;
wire \clock_divider|Equal0~1_combout ;
wire \clock_divider|Equal0~2_combout ;
wire \clock_divider|out~regout ;
wire \matrix|columns[0]~0 ;
wire \matrix|Decoder0~0 ;
wire [4:0] \matrix|columns ;
wire [3:0] \matrix|count ;
wire [15:0] \clock_divider|count ;


// Location: PIN_12,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \clock~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\clock~combout ),
	.padio(clock));
// synopsys translate_off
defparam \clock~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X6_Y3_N2
maxii_lcell \clock_divider|count[0] (
// Equation(s):
// \clock_divider|count [0] = DFFEAS(((!\clock_divider|count [0])), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[0]~1  = CARRY(((\clock_divider|count [0])))
// \clock_divider|count[0]~1COUT1_33  = CARRY(((\clock_divider|count [0])))

	.clk(\clock~combout ),
	.dataa(vcc),
	.datab(\clock_divider|count [0]),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [0]),
	.cout(),
	.cout0(\clock_divider|count[0]~1 ),
	.cout1(\clock_divider|count[0]~1COUT1_33 ));
// synopsys translate_off
defparam \clock_divider|count[0] .lut_mask = "33cc";
defparam \clock_divider|count[0] .operation_mode = "arithmetic";
defparam \clock_divider|count[0] .output_mode = "reg_only";
defparam \clock_divider|count[0] .register_cascade_mode = "off";
defparam \clock_divider|count[0] .sum_lutc_input = "datac";
defparam \clock_divider|count[0] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N3
maxii_lcell \clock_divider|count[1] (
// Equation(s):
// \clock_divider|count [1] = DFFEAS(\clock_divider|count [1] $ ((((\clock_divider|count[0]~1 )))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[1]~3  = CARRY(((!\clock_divider|count[0]~1 )) # (!\clock_divider|count [1]))
// \clock_divider|count[1]~3COUT1_34  = CARRY(((!\clock_divider|count[0]~1COUT1_33 )) # (!\clock_divider|count [1]))

	.clk(\clock~combout ),
	.dataa(\clock_divider|count [1]),
	.datab(vcc),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(\clock_divider|count[0]~1 ),
	.cin1(\clock_divider|count[0]~1COUT1_33 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [1]),
	.cout(),
	.cout0(\clock_divider|count[1]~3 ),
	.cout1(\clock_divider|count[1]~3COUT1_34 ));
// synopsys translate_off
defparam \clock_divider|count[1] .cin0_used = "true";
defparam \clock_divider|count[1] .cin1_used = "true";
defparam \clock_divider|count[1] .lut_mask = "5a5f";
defparam \clock_divider|count[1] .operation_mode = "arithmetic";
defparam \clock_divider|count[1] .output_mode = "reg_only";
defparam \clock_divider|count[1] .register_cascade_mode = "off";
defparam \clock_divider|count[1] .sum_lutc_input = "cin";
defparam \clock_divider|count[1] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N4
maxii_lcell \clock_divider|count[2] (
// Equation(s):
// \clock_divider|count [2] = DFFEAS(\clock_divider|count [2] $ ((((!\clock_divider|count[1]~3 )))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[2]~5  = CARRY((\clock_divider|count [2] & ((!\clock_divider|count[1]~3COUT1_34 ))))

	.clk(\clock~combout ),
	.dataa(\clock_divider|count [2]),
	.datab(vcc),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(\clock_divider|count[1]~3 ),
	.cin1(\clock_divider|count[1]~3COUT1_34 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [2]),
	.cout(\clock_divider|count[2]~5 ),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \clock_divider|count[2] .cin0_used = "true";
defparam \clock_divider|count[2] .cin1_used = "true";
defparam \clock_divider|count[2] .lut_mask = "a50a";
defparam \clock_divider|count[2] .operation_mode = "arithmetic";
defparam \clock_divider|count[2] .output_mode = "reg_only";
defparam \clock_divider|count[2] .register_cascade_mode = "off";
defparam \clock_divider|count[2] .sum_lutc_input = "cin";
defparam \clock_divider|count[2] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N5
maxii_lcell \clock_divider|count[3] (
// Equation(s):
// \clock_divider|count [3] = DFFEAS(\clock_divider|count [3] $ ((((\clock_divider|count[2]~5 )))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[3]~7  = CARRY(((!\clock_divider|count[2]~5 )) # (!\clock_divider|count [3]))
// \clock_divider|count[3]~7COUT1_35  = CARRY(((!\clock_divider|count[2]~5 )) # (!\clock_divider|count [3]))

	.clk(\clock~combout ),
	.dataa(\clock_divider|count [3]),
	.datab(vcc),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[2]~5 ),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [3]),
	.cout(),
	.cout0(\clock_divider|count[3]~7 ),
	.cout1(\clock_divider|count[3]~7COUT1_35 ));
// synopsys translate_off
defparam \clock_divider|count[3] .cin_used = "true";
defparam \clock_divider|count[3] .lut_mask = "5a5f";
defparam \clock_divider|count[3] .operation_mode = "arithmetic";
defparam \clock_divider|count[3] .output_mode = "reg_only";
defparam \clock_divider|count[3] .register_cascade_mode = "off";
defparam \clock_divider|count[3] .sum_lutc_input = "cin";
defparam \clock_divider|count[3] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N6
maxii_lcell \clock_divider|count[4] (
// Equation(s):
// \clock_divider|count [4] = DFFEAS(\clock_divider|count [4] $ ((((!(!\clock_divider|count[2]~5  & \clock_divider|count[3]~7 ) # (\clock_divider|count[2]~5  & \clock_divider|count[3]~7COUT1_35 ))))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[4]~9  = CARRY((\clock_divider|count [4] & ((!\clock_divider|count[3]~7 ))))
// \clock_divider|count[4]~9COUT1_36  = CARRY((\clock_divider|count [4] & ((!\clock_divider|count[3]~7COUT1_35 ))))

	.clk(\clock~combout ),
	.dataa(\clock_divider|count [4]),
	.datab(vcc),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[2]~5 ),
	.cin0(\clock_divider|count[3]~7 ),
	.cin1(\clock_divider|count[3]~7COUT1_35 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [4]),
	.cout(),
	.cout0(\clock_divider|count[4]~9 ),
	.cout1(\clock_divider|count[4]~9COUT1_36 ));
// synopsys translate_off
defparam \clock_divider|count[4] .cin0_used = "true";
defparam \clock_divider|count[4] .cin1_used = "true";
defparam \clock_divider|count[4] .cin_used = "true";
defparam \clock_divider|count[4] .lut_mask = "a50a";
defparam \clock_divider|count[4] .operation_mode = "arithmetic";
defparam \clock_divider|count[4] .output_mode = "reg_only";
defparam \clock_divider|count[4] .register_cascade_mode = "off";
defparam \clock_divider|count[4] .sum_lutc_input = "cin";
defparam \clock_divider|count[4] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N7
maxii_lcell \clock_divider|count[5] (
// Equation(s):
// \clock_divider|count [5] = DFFEAS((\clock_divider|count [5] $ (((!\clock_divider|count[2]~5  & \clock_divider|count[4]~9 ) # (\clock_divider|count[2]~5  & \clock_divider|count[4]~9COUT1_36 )))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[5]~11  = CARRY(((!\clock_divider|count[4]~9 ) # (!\clock_divider|count [5])))
// \clock_divider|count[5]~11COUT1_37  = CARRY(((!\clock_divider|count[4]~9COUT1_36 ) # (!\clock_divider|count [5])))

	.clk(\clock~combout ),
	.dataa(vcc),
	.datab(\clock_divider|count [5]),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[2]~5 ),
	.cin0(\clock_divider|count[4]~9 ),
	.cin1(\clock_divider|count[4]~9COUT1_36 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [5]),
	.cout(),
	.cout0(\clock_divider|count[5]~11 ),
	.cout1(\clock_divider|count[5]~11COUT1_37 ));
// synopsys translate_off
defparam \clock_divider|count[5] .cin0_used = "true";
defparam \clock_divider|count[5] .cin1_used = "true";
defparam \clock_divider|count[5] .cin_used = "true";
defparam \clock_divider|count[5] .lut_mask = "3c3f";
defparam \clock_divider|count[5] .operation_mode = "arithmetic";
defparam \clock_divider|count[5] .output_mode = "reg_only";
defparam \clock_divider|count[5] .register_cascade_mode = "off";
defparam \clock_divider|count[5] .sum_lutc_input = "cin";
defparam \clock_divider|count[5] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N8
maxii_lcell \clock_divider|count[6] (
// Equation(s):
// \clock_divider|count [6] = DFFEAS(\clock_divider|count [6] $ ((((!(!\clock_divider|count[2]~5  & \clock_divider|count[5]~11 ) # (\clock_divider|count[2]~5  & \clock_divider|count[5]~11COUT1_37 ))))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[6]~13  = CARRY((\clock_divider|count [6] & ((!\clock_divider|count[5]~11 ))))
// \clock_divider|count[6]~13COUT1_38  = CARRY((\clock_divider|count [6] & ((!\clock_divider|count[5]~11COUT1_37 ))))

	.clk(\clock~combout ),
	.dataa(\clock_divider|count [6]),
	.datab(vcc),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[2]~5 ),
	.cin0(\clock_divider|count[5]~11 ),
	.cin1(\clock_divider|count[5]~11COUT1_37 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [6]),
	.cout(),
	.cout0(\clock_divider|count[6]~13 ),
	.cout1(\clock_divider|count[6]~13COUT1_38 ));
// synopsys translate_off
defparam \clock_divider|count[6] .cin0_used = "true";
defparam \clock_divider|count[6] .cin1_used = "true";
defparam \clock_divider|count[6] .cin_used = "true";
defparam \clock_divider|count[6] .lut_mask = "a50a";
defparam \clock_divider|count[6] .operation_mode = "arithmetic";
defparam \clock_divider|count[6] .output_mode = "reg_only";
defparam \clock_divider|count[6] .register_cascade_mode = "off";
defparam \clock_divider|count[6] .sum_lutc_input = "cin";
defparam \clock_divider|count[6] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N9
maxii_lcell \clock_divider|count[7] (
// Equation(s):
// \clock_divider|count [7] = DFFEAS((\clock_divider|count [7] $ (((!\clock_divider|count[2]~5  & \clock_divider|count[6]~13 ) # (\clock_divider|count[2]~5  & \clock_divider|count[6]~13COUT1_38 )))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[7]~15  = CARRY(((!\clock_divider|count[6]~13COUT1_38 ) # (!\clock_divider|count [7])))

	.clk(\clock~combout ),
	.dataa(vcc),
	.datab(\clock_divider|count [7]),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[2]~5 ),
	.cin0(\clock_divider|count[6]~13 ),
	.cin1(\clock_divider|count[6]~13COUT1_38 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [7]),
	.cout(\clock_divider|count[7]~15 ),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \clock_divider|count[7] .cin0_used = "true";
defparam \clock_divider|count[7] .cin1_used = "true";
defparam \clock_divider|count[7] .cin_used = "true";
defparam \clock_divider|count[7] .lut_mask = "3c3f";
defparam \clock_divider|count[7] .operation_mode = "arithmetic";
defparam \clock_divider|count[7] .output_mode = "reg_only";
defparam \clock_divider|count[7] .register_cascade_mode = "off";
defparam \clock_divider|count[7] .sum_lutc_input = "cin";
defparam \clock_divider|count[7] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y3_N0
maxii_lcell \clock_divider|count[8] (
// Equation(s):
// \clock_divider|count [8] = DFFEAS((\clock_divider|count [8] $ ((!\clock_divider|count[7]~15 ))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[8]~17  = CARRY(((\clock_divider|count [8] & !\clock_divider|count[7]~15 )))
// \clock_divider|count[8]~17COUT1_39  = CARRY(((\clock_divider|count [8] & !\clock_divider|count[7]~15 )))

	.clk(\clock~combout ),
	.dataa(vcc),
	.datab(\clock_divider|count [8]),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[7]~15 ),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [8]),
	.cout(),
	.cout0(\clock_divider|count[8]~17 ),
	.cout1(\clock_divider|count[8]~17COUT1_39 ));
// synopsys translate_off
defparam \clock_divider|count[8] .cin_used = "true";
defparam \clock_divider|count[8] .lut_mask = "c30c";
defparam \clock_divider|count[8] .operation_mode = "arithmetic";
defparam \clock_divider|count[8] .output_mode = "reg_only";
defparam \clock_divider|count[8] .register_cascade_mode = "off";
defparam \clock_divider|count[8] .sum_lutc_input = "cin";
defparam \clock_divider|count[8] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y3_N1
maxii_lcell \clock_divider|count[9] (
// Equation(s):
// \clock_divider|count [9] = DFFEAS((\clock_divider|count [9] $ (((!\clock_divider|count[7]~15  & \clock_divider|count[8]~17 ) # (\clock_divider|count[7]~15  & \clock_divider|count[8]~17COUT1_39 )))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[9]~19  = CARRY(((!\clock_divider|count[8]~17 ) # (!\clock_divider|count [9])))
// \clock_divider|count[9]~19COUT1_40  = CARRY(((!\clock_divider|count[8]~17COUT1_39 ) # (!\clock_divider|count [9])))

	.clk(\clock~combout ),
	.dataa(vcc),
	.datab(\clock_divider|count [9]),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[7]~15 ),
	.cin0(\clock_divider|count[8]~17 ),
	.cin1(\clock_divider|count[8]~17COUT1_39 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [9]),
	.cout(),
	.cout0(\clock_divider|count[9]~19 ),
	.cout1(\clock_divider|count[9]~19COUT1_40 ));
// synopsys translate_off
defparam \clock_divider|count[9] .cin0_used = "true";
defparam \clock_divider|count[9] .cin1_used = "true";
defparam \clock_divider|count[9] .cin_used = "true";
defparam \clock_divider|count[9] .lut_mask = "3c3f";
defparam \clock_divider|count[9] .operation_mode = "arithmetic";
defparam \clock_divider|count[9] .output_mode = "reg_only";
defparam \clock_divider|count[9] .register_cascade_mode = "off";
defparam \clock_divider|count[9] .sum_lutc_input = "cin";
defparam \clock_divider|count[9] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y3_N2
maxii_lcell \clock_divider|count[10] (
// Equation(s):
// \clock_divider|count [10] = DFFEAS((\clock_divider|count [10] $ ((!(!\clock_divider|count[7]~15  & \clock_divider|count[9]~19 ) # (\clock_divider|count[7]~15  & \clock_divider|count[9]~19COUT1_40 )))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[10]~21  = CARRY(((\clock_divider|count [10] & !\clock_divider|count[9]~19 )))
// \clock_divider|count[10]~21COUT1_41  = CARRY(((\clock_divider|count [10] & !\clock_divider|count[9]~19COUT1_40 )))

	.clk(\clock~combout ),
	.dataa(vcc),
	.datab(\clock_divider|count [10]),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[7]~15 ),
	.cin0(\clock_divider|count[9]~19 ),
	.cin1(\clock_divider|count[9]~19COUT1_40 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [10]),
	.cout(),
	.cout0(\clock_divider|count[10]~21 ),
	.cout1(\clock_divider|count[10]~21COUT1_41 ));
// synopsys translate_off
defparam \clock_divider|count[10] .cin0_used = "true";
defparam \clock_divider|count[10] .cin1_used = "true";
defparam \clock_divider|count[10] .cin_used = "true";
defparam \clock_divider|count[10] .lut_mask = "c30c";
defparam \clock_divider|count[10] .operation_mode = "arithmetic";
defparam \clock_divider|count[10] .output_mode = "reg_only";
defparam \clock_divider|count[10] .register_cascade_mode = "off";
defparam \clock_divider|count[10] .sum_lutc_input = "cin";
defparam \clock_divider|count[10] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y3_N3
maxii_lcell \clock_divider|count[11] (
// Equation(s):
// \clock_divider|count [11] = DFFEAS(\clock_divider|count [11] $ (((((!\clock_divider|count[7]~15  & \clock_divider|count[10]~21 ) # (\clock_divider|count[7]~15  & \clock_divider|count[10]~21COUT1_41 ))))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[11]~23  = CARRY(((!\clock_divider|count[10]~21 )) # (!\clock_divider|count [11]))
// \clock_divider|count[11]~23COUT1_42  = CARRY(((!\clock_divider|count[10]~21COUT1_41 )) # (!\clock_divider|count [11]))

	.clk(\clock~combout ),
	.dataa(\clock_divider|count [11]),
	.datab(vcc),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[7]~15 ),
	.cin0(\clock_divider|count[10]~21 ),
	.cin1(\clock_divider|count[10]~21COUT1_41 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [11]),
	.cout(),
	.cout0(\clock_divider|count[11]~23 ),
	.cout1(\clock_divider|count[11]~23COUT1_42 ));
// synopsys translate_off
defparam \clock_divider|count[11] .cin0_used = "true";
defparam \clock_divider|count[11] .cin1_used = "true";
defparam \clock_divider|count[11] .cin_used = "true";
defparam \clock_divider|count[11] .lut_mask = "5a5f";
defparam \clock_divider|count[11] .operation_mode = "arithmetic";
defparam \clock_divider|count[11] .output_mode = "reg_only";
defparam \clock_divider|count[11] .register_cascade_mode = "off";
defparam \clock_divider|count[11] .sum_lutc_input = "cin";
defparam \clock_divider|count[11] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y3_N9
maxii_lcell \clock_divider|Equal0~3 (
// Equation(s):
// \clock_divider|Equal0~3_combout  = (\clock_divider|count [11] & (\clock_divider|count [10] & (\clock_divider|count [8] & \clock_divider|count [9])))

	.clk(gnd),
	.dataa(\clock_divider|count [11]),
	.datab(\clock_divider|count [10]),
	.datac(\clock_divider|count [8]),
	.datad(\clock_divider|count [9]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\clock_divider|Equal0~3_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \clock_divider|Equal0~3 .lut_mask = "8000";
defparam \clock_divider|Equal0~3 .operation_mode = "normal";
defparam \clock_divider|Equal0~3 .output_mode = "comb_only";
defparam \clock_divider|Equal0~3 .register_cascade_mode = "off";
defparam \clock_divider|Equal0~3 .sum_lutc_input = "datac";
defparam \clock_divider|Equal0~3 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y3_N4
maxii_lcell \clock_divider|count[12] (
// Equation(s):
// \clock_divider|count [12] = DFFEAS(\clock_divider|count [12] $ ((((!(!\clock_divider|count[7]~15  & \clock_divider|count[11]~23 ) # (\clock_divider|count[7]~15  & \clock_divider|count[11]~23COUT1_42 ))))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[12]~25  = CARRY((\clock_divider|count [12] & ((!\clock_divider|count[11]~23COUT1_42 ))))

	.clk(\clock~combout ),
	.dataa(\clock_divider|count [12]),
	.datab(vcc),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[7]~15 ),
	.cin0(\clock_divider|count[11]~23 ),
	.cin1(\clock_divider|count[11]~23COUT1_42 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [12]),
	.cout(\clock_divider|count[12]~25 ),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \clock_divider|count[12] .cin0_used = "true";
defparam \clock_divider|count[12] .cin1_used = "true";
defparam \clock_divider|count[12] .cin_used = "true";
defparam \clock_divider|count[12] .lut_mask = "a50a";
defparam \clock_divider|count[12] .operation_mode = "arithmetic";
defparam \clock_divider|count[12] .output_mode = "reg_only";
defparam \clock_divider|count[12] .register_cascade_mode = "off";
defparam \clock_divider|count[12] .sum_lutc_input = "cin";
defparam \clock_divider|count[12] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y3_N5
maxii_lcell \clock_divider|count[13] (
// Equation(s):
// \clock_divider|count [13] = DFFEAS(\clock_divider|count [13] $ ((((\clock_divider|count[12]~25 )))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[13]~27  = CARRY(((!\clock_divider|count[12]~25 )) # (!\clock_divider|count [13]))
// \clock_divider|count[13]~27COUT1_43  = CARRY(((!\clock_divider|count[12]~25 )) # (!\clock_divider|count [13]))

	.clk(\clock~combout ),
	.dataa(\clock_divider|count [13]),
	.datab(vcc),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[12]~25 ),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [13]),
	.cout(),
	.cout0(\clock_divider|count[13]~27 ),
	.cout1(\clock_divider|count[13]~27COUT1_43 ));
// synopsys translate_off
defparam \clock_divider|count[13] .cin_used = "true";
defparam \clock_divider|count[13] .lut_mask = "5a5f";
defparam \clock_divider|count[13] .operation_mode = "arithmetic";
defparam \clock_divider|count[13] .output_mode = "reg_only";
defparam \clock_divider|count[13] .register_cascade_mode = "off";
defparam \clock_divider|count[13] .sum_lutc_input = "cin";
defparam \clock_divider|count[13] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y3_N6
maxii_lcell \clock_divider|count[14] (
// Equation(s):
// \clock_divider|count [14] = DFFEAS(\clock_divider|count [14] $ ((((!(!\clock_divider|count[12]~25  & \clock_divider|count[13]~27 ) # (\clock_divider|count[12]~25  & \clock_divider|count[13]~27COUT1_43 ))))), GLOBAL(\clock~combout ), VCC, , , , , , )
// \clock_divider|count[14]~29  = CARRY((\clock_divider|count [14] & ((!\clock_divider|count[13]~27 ))))
// \clock_divider|count[14]~29COUT1_44  = CARRY((\clock_divider|count [14] & ((!\clock_divider|count[13]~27COUT1_43 ))))

	.clk(\clock~combout ),
	.dataa(\clock_divider|count [14]),
	.datab(vcc),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[12]~25 ),
	.cin0(\clock_divider|count[13]~27 ),
	.cin1(\clock_divider|count[13]~27COUT1_43 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [14]),
	.cout(),
	.cout0(\clock_divider|count[14]~29 ),
	.cout1(\clock_divider|count[14]~29COUT1_44 ));
// synopsys translate_off
defparam \clock_divider|count[14] .cin0_used = "true";
defparam \clock_divider|count[14] .cin1_used = "true";
defparam \clock_divider|count[14] .cin_used = "true";
defparam \clock_divider|count[14] .lut_mask = "a50a";
defparam \clock_divider|count[14] .operation_mode = "arithmetic";
defparam \clock_divider|count[14] .output_mode = "reg_only";
defparam \clock_divider|count[14] .register_cascade_mode = "off";
defparam \clock_divider|count[14] .sum_lutc_input = "cin";
defparam \clock_divider|count[14] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y3_N7
maxii_lcell \clock_divider|count[15] (
// Equation(s):
// \clock_divider|count [15] = DFFEAS((\clock_divider|count [15] $ (((!\clock_divider|count[12]~25  & \clock_divider|count[14]~29 ) # (\clock_divider|count[12]~25  & \clock_divider|count[14]~29COUT1_44 )))), GLOBAL(\clock~combout ), VCC, , , , , , )

	.clk(\clock~combout ),
	.dataa(vcc),
	.datab(\clock_divider|count [15]),
	.datac(vcc),
	.datad(vcc),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(\clock_divider|count[12]~25 ),
	.cin0(\clock_divider|count[14]~29 ),
	.cin1(\clock_divider|count[14]~29COUT1_44 ),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|count [15]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \clock_divider|count[15] .cin0_used = "true";
defparam \clock_divider|count[15] .cin1_used = "true";
defparam \clock_divider|count[15] .cin_used = "true";
defparam \clock_divider|count[15] .lut_mask = "3c3c";
defparam \clock_divider|count[15] .operation_mode = "normal";
defparam \clock_divider|count[15] .output_mode = "reg_only";
defparam \clock_divider|count[15] .register_cascade_mode = "off";
defparam \clock_divider|count[15] .sum_lutc_input = "cin";
defparam \clock_divider|count[15] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y3_N8
maxii_lcell \clock_divider|Equal0~4 (
// Equation(s):
// \clock_divider|Equal0~4_combout  = (\clock_divider|count [14] & (\clock_divider|count [15] & (\clock_divider|count [13] & \clock_divider|count [12])))

	.clk(gnd),
	.dataa(\clock_divider|count [14]),
	.datab(\clock_divider|count [15]),
	.datac(\clock_divider|count [13]),
	.datad(\clock_divider|count [12]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\clock_divider|Equal0~4_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \clock_divider|Equal0~4 .lut_mask = "8000";
defparam \clock_divider|Equal0~4 .operation_mode = "normal";
defparam \clock_divider|Equal0~4 .output_mode = "comb_only";
defparam \clock_divider|Equal0~4 .register_cascade_mode = "off";
defparam \clock_divider|Equal0~4 .sum_lutc_input = "datac";
defparam \clock_divider|Equal0~4 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N0
maxii_lcell \clock_divider|Equal0~0 (
// Equation(s):
// \clock_divider|Equal0~0_combout  = ((\clock_divider|count [0] & ((\clock_divider|count [1]))))

	.clk(gnd),
	.dataa(vcc),
	.datab(\clock_divider|count [0]),
	.datac(vcc),
	.datad(\clock_divider|count [1]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\clock_divider|Equal0~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \clock_divider|Equal0~0 .lut_mask = "cc00";
defparam \clock_divider|Equal0~0 .operation_mode = "normal";
defparam \clock_divider|Equal0~0 .output_mode = "comb_only";
defparam \clock_divider|Equal0~0 .register_cascade_mode = "off";
defparam \clock_divider|Equal0~0 .sum_lutc_input = "datac";
defparam \clock_divider|Equal0~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N1
maxii_lcell \clock_divider|Equal0~1 (
// Equation(s):
// \clock_divider|Equal0~1_combout  = (\clock_divider|count [4] & (\clock_divider|count [7] & (\clock_divider|count [5] & \clock_divider|count [6])))

	.clk(gnd),
	.dataa(\clock_divider|count [4]),
	.datab(\clock_divider|count [7]),
	.datac(\clock_divider|count [5]),
	.datad(\clock_divider|count [6]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\clock_divider|Equal0~1_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \clock_divider|Equal0~1 .lut_mask = "8000";
defparam \clock_divider|Equal0~1 .operation_mode = "normal";
defparam \clock_divider|Equal0~1 .output_mode = "comb_only";
defparam \clock_divider|Equal0~1 .register_cascade_mode = "off";
defparam \clock_divider|Equal0~1 .sum_lutc_input = "datac";
defparam \clock_divider|Equal0~1 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N1
maxii_lcell \clock_divider|Equal0~2 (
// Equation(s):
// \clock_divider|Equal0~2_combout  = (\clock_divider|count [3] & (\clock_divider|count [2] & (\clock_divider|Equal0~0_combout  & \clock_divider|Equal0~1_combout )))

	.clk(gnd),
	.dataa(\clock_divider|count [3]),
	.datab(\clock_divider|count [2]),
	.datac(\clock_divider|Equal0~0_combout ),
	.datad(\clock_divider|Equal0~1_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\clock_divider|Equal0~2_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \clock_divider|Equal0~2 .lut_mask = "8000";
defparam \clock_divider|Equal0~2 .operation_mode = "normal";
defparam \clock_divider|Equal0~2 .output_mode = "comb_only";
defparam \clock_divider|Equal0~2 .register_cascade_mode = "off";
defparam \clock_divider|Equal0~2 .sum_lutc_input = "datac";
defparam \clock_divider|Equal0~2 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N2
maxii_lcell \clock_divider|out (
// Equation(s):
// \clock_divider|out~regout  = DFFEAS(\clock_divider|out~regout  $ (((\clock_divider|Equal0~3_combout  & (\clock_divider|Equal0~4_combout  & \clock_divider|Equal0~2_combout )))), GLOBAL(\clock~combout ), VCC, , , , , , )

	.clk(\clock~combout ),
	.dataa(\clock_divider|out~regout ),
	.datab(\clock_divider|Equal0~3_combout ),
	.datac(\clock_divider|Equal0~4_combout ),
	.datad(\clock_divider|Equal0~2_combout ),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\clock_divider|out~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \clock_divider|out .lut_mask = "6aaa";
defparam \clock_divider|out .operation_mode = "normal";
defparam \clock_divider|out .output_mode = "reg_only";
defparam \clock_divider|out .register_cascade_mode = "off";
defparam \clock_divider|out .sum_lutc_input = "datac";
defparam \clock_divider|out .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y1_N0
maxii_lcell \matrix|count[2] (
// Equation(s):
// \matrix|columns[0]~0  = (((!\matrix|count [0] & !\matrix|count [1])) # (!E1_count[2]))
// \matrix|count [2] = DFFEAS(\matrix|columns[0]~0 , GLOBAL(\clock_divider|out~regout ), VCC, , , \matrix|Decoder0~0 , , , VCC)

	.clk(\clock_divider|out~regout ),
	.dataa(vcc),
	.datab(\matrix|count [0]),
	.datac(\matrix|Decoder0~0 ),
	.datad(\matrix|count [1]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\matrix|columns[0]~0 ),
	.regout(\matrix|count [2]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \matrix|count[2] .lut_mask = "0f3f";
defparam \matrix|count[2] .operation_mode = "normal";
defparam \matrix|count[2] .output_mode = "reg_and_comb";
defparam \matrix|count[2] .register_cascade_mode = "off";
defparam \matrix|count[2] .sum_lutc_input = "qfbk";
defparam \matrix|count[2] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X7_Y1_N6
maxii_lcell \matrix|columns[3] (
// Equation(s):
// \matrix|Decoder0~0  = (\matrix|count [1] & (((\matrix|count [0] & !\matrix|count [2]))))
// \matrix|columns [3] = DFFEAS(\matrix|Decoder0~0 , GLOBAL(\clock_divider|out~regout ), VCC, , \matrix|columns[0]~0 , , , , )

	.clk(\clock_divider|out~regout ),
	.dataa(\matrix|count [1]),
	.datab(vcc),
	.datac(\matrix|count [0]),
	.datad(\matrix|count [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\matrix|columns[0]~0 ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\matrix|Decoder0~0 ),
	.regout(\matrix|columns [3]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \matrix|columns[3] .lut_mask = "00a0";
defparam \matrix|columns[3] .operation_mode = "normal";
defparam \matrix|columns[3] .output_mode = "reg_and_comb";
defparam \matrix|columns[3] .register_cascade_mode = "off";
defparam \matrix|columns[3] .sum_lutc_input = "datac";
defparam \matrix|columns[3] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y1_N9
maxii_lcell \matrix|count[0] (
// Equation(s):
// \matrix|count [0] = DFFEAS(((!\matrix|count [0] & ((!\matrix|count [2])))), GLOBAL(\clock_divider|out~regout ), VCC, , , , , , )

	.clk(\clock_divider|out~regout ),
	.dataa(vcc),
	.datab(\matrix|count [0]),
	.datac(vcc),
	.datad(\matrix|count [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\matrix|count [0]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \matrix|count[0] .lut_mask = "0033";
defparam \matrix|count[0] .operation_mode = "normal";
defparam \matrix|count[0] .output_mode = "reg_only";
defparam \matrix|count[0] .register_cascade_mode = "off";
defparam \matrix|count[0] .sum_lutc_input = "datac";
defparam \matrix|count[0] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y1_N3
maxii_lcell \matrix|count[1] (
// Equation(s):
// \matrix|count [1] = DFFEAS(((!\matrix|count [2] & (\matrix|count [1] $ (\matrix|count [0])))), GLOBAL(\clock_divider|out~regout ), VCC, , , , , , )

	.clk(\clock_divider|out~regout ),
	.dataa(\matrix|count [1]),
	.datab(\matrix|count [0]),
	.datac(vcc),
	.datad(\matrix|count [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\matrix|count [1]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \matrix|count[1] .lut_mask = "0066";
defparam \matrix|count[1] .operation_mode = "normal";
defparam \matrix|count[1] .output_mode = "reg_only";
defparam \matrix|count[1] .register_cascade_mode = "off";
defparam \matrix|count[1] .sum_lutc_input = "datac";
defparam \matrix|count[1] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y1_N4
maxii_lcell \matrix|columns[0] (
// Equation(s):
// \matrix|columns [0] = DFFEAS((!\matrix|count [1] & (!\matrix|count [0] & ((!\matrix|count [2])))), GLOBAL(\clock_divider|out~regout ), VCC, , \matrix|columns[0]~0 , , , , )

	.clk(\clock_divider|out~regout ),
	.dataa(\matrix|count [1]),
	.datab(\matrix|count [0]),
	.datac(vcc),
	.datad(\matrix|count [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\matrix|columns[0]~0 ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\matrix|columns [0]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \matrix|columns[0] .lut_mask = "0011";
defparam \matrix|columns[0] .operation_mode = "normal";
defparam \matrix|columns[0] .output_mode = "reg_only";
defparam \matrix|columns[0] .register_cascade_mode = "off";
defparam \matrix|columns[0] .sum_lutc_input = "datac";
defparam \matrix|columns[0] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y1_N7
maxii_lcell \matrix|columns[1] (
// Equation(s):
// \matrix|columns [1] = DFFEAS((!\matrix|count [1] & (\matrix|count [0] & ((!\matrix|count [2])))), GLOBAL(\clock_divider|out~regout ), VCC, , \matrix|columns[0]~0 , , , , )

	.clk(\clock_divider|out~regout ),
	.dataa(\matrix|count [1]),
	.datab(\matrix|count [0]),
	.datac(vcc),
	.datad(\matrix|count [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\matrix|columns[0]~0 ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\matrix|columns [1]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \matrix|columns[1] .lut_mask = "0044";
defparam \matrix|columns[1] .operation_mode = "normal";
defparam \matrix|columns[1] .output_mode = "reg_only";
defparam \matrix|columns[1] .register_cascade_mode = "off";
defparam \matrix|columns[1] .sum_lutc_input = "datac";
defparam \matrix|columns[1] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y1_N2
maxii_lcell \matrix|columns[2] (
// Equation(s):
// \matrix|columns [2] = DFFEAS((\matrix|count [1] & (!\matrix|count [0] & ((!\matrix|count [2])))), GLOBAL(\clock_divider|out~regout ), VCC, , \matrix|columns[0]~0 , , , , )

	.clk(\clock_divider|out~regout ),
	.dataa(\matrix|count [1]),
	.datab(\matrix|count [0]),
	.datac(vcc),
	.datad(\matrix|count [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\matrix|columns[0]~0 ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\matrix|columns [2]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \matrix|columns[2] .lut_mask = "0022";
defparam \matrix|columns[2] .operation_mode = "normal";
defparam \matrix|columns[2] .output_mode = "reg_only";
defparam \matrix|columns[2] .register_cascade_mode = "off";
defparam \matrix|columns[2] .sum_lutc_input = "datac";
defparam \matrix|columns[2] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y1_N8
maxii_lcell \matrix|columns[4] (
// Equation(s):
// \matrix|columns [4] = DFFEAS((((\matrix|count [2]))), GLOBAL(\clock_divider|out~regout ), VCC, , \matrix|columns[0]~0 , , , , )

	.clk(\clock_divider|out~regout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\matrix|count [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\matrix|columns[0]~0 ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\matrix|columns [4]),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \matrix|columns[4] .lut_mask = "ff00";
defparam \matrix|columns[4] .operation_mode = "normal";
defparam \matrix|columns[4] .output_mode = "reg_only";
defparam \matrix|columns[4] .register_cascade_mode = "off";
defparam \matrix|columns[4] .sum_lutc_input = "datac";
defparam \matrix|columns[4] .synch_mode = "off";
// synopsys translate_on

// Location: PIN_64,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \status[0]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(status[0]));
// synopsys translate_off
defparam \status[0]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_57,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \status[1]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(status[1]));
// synopsys translate_off
defparam \status[1]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_33,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \columns_attack[0]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(columns_attack[0]));
// synopsys translate_off
defparam \columns_attack[0]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_15,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \columns_attack[1]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(columns_attack[1]));
// synopsys translate_off
defparam \columns_attack[1]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_5,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \columns_attack[2]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(columns_attack[2]));
// synopsys translate_off
defparam \columns_attack[2]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_61,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \rows_attack[0]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(rows_attack[0]));
// synopsys translate_off
defparam \rows_attack[0]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_92,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \rows_attack[1]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(rows_attack[1]));
// synopsys translate_off
defparam \rows_attack[1]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_83,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \rows_attack[2]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(rows_attack[2]));
// synopsys translate_off
defparam \rows_attack[2]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_84,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \attack_button~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(attack_button));
// synopsys translate_off
defparam \attack_button~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_91,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \save_game_button~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(save_game_button));
// synopsys translate_off
defparam \save_game_button~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_95,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \reset_save_game_button~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(reset_save_game_button));
// synopsys translate_off
defparam \reset_save_game_button~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_54,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \columns[0]~I (
	.datain(\matrix|columns [0]),
	.oe(vcc),
	.combout(),
	.padio(columns[0]));
// synopsys translate_off
defparam \columns[0]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_55,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \columns[1]~I (
	.datain(\matrix|columns [1]),
	.oe(vcc),
	.combout(),
	.padio(columns[1]));
// synopsys translate_off
defparam \columns[1]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_56,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \columns[2]~I (
	.datain(\matrix|columns [2]),
	.oe(vcc),
	.combout(),
	.padio(columns[2]));
// synopsys translate_off
defparam \columns[2]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_53,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \columns[3]~I (
	.datain(\matrix|columns [3]),
	.oe(vcc),
	.combout(),
	.padio(columns[3]));
// synopsys translate_off
defparam \columns[3]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_52,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \columns[4]~I (
	.datain(\matrix|columns [4]),
	.oe(vcc),
	.combout(),
	.padio(columns[4]));
// synopsys translate_off
defparam \columns[4]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_70,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \lines[0]~I (
	.datain(gnd),
	.oe(vcc),
	.combout(),
	.padio(lines[0]));
// synopsys translate_off
defparam \lines[0]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_43,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \lines[1]~I (
	.datain(gnd),
	.oe(vcc),
	.combout(),
	.padio(lines[1]));
// synopsys translate_off
defparam \lines[1]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_17,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \lines[2]~I (
	.datain(gnd),
	.oe(vcc),
	.combout(),
	.padio(lines[2]));
// synopsys translate_off
defparam \lines[2]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_20,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \lines[3]~I (
	.datain(gnd),
	.oe(vcc),
	.combout(),
	.padio(lines[3]));
// synopsys translate_off
defparam \lines[3]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_29,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \lines[4]~I (
	.datain(gnd),
	.oe(vcc),
	.combout(),
	.padio(lines[4]));
// synopsys translate_off
defparam \lines[4]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_98,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \lines[5]~I (
	.datain(gnd),
	.oe(vcc),
	.combout(),
	.padio(lines[5]));
// synopsys translate_off
defparam \lines[5]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_51,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \lines[6]~I (
	.datain(gnd),
	.oe(vcc),
	.combout(),
	.padio(lines[6]));
// synopsys translate_off
defparam \lines[6]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_6,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxii_io \clock_output~I (
	.datain(\clock_divider|out~regout ),
	.oe(vcc),
	.combout(),
	.padio(clock_output));
// synopsys translate_off
defparam \clock_output~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_3,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxii_io \game_charge_button~I (
	.datain(gnd),
	.oe(gnd),
	.combout(),
	.padio(game_charge_button));
// synopsys translate_off
defparam \game_charge_button~I .operation_mode = "input";
// synopsys translate_on

endmodule
